/**
 * Cross Domain Tracking Script
 * Version: 7.0
 * This script is used on a Next.js v14 pages router app and is injected into the app's `<head>` tag using a Cloudflare worker before the page has rendered.
 * It handles cross-domain tracking, URL parameter management, and redirects while ensuring compatibility with Google Ads tracking scripts.
 *
 * For detailed documentation and examples, refer to each function's JSDoc comments below.
 */
(() => {
  /* __________________________________ Constants and Configurations __________________________________ */

  /** Cross Domain Tracking Version */
  const CROSS_DOMAIN_TRACKING_VERSION = '7.6.0'
  const DEFAULT_TTL_EXPIRY = 1000 * 60 * 60 * 24 // 24 hours / 1 Day Expiry
  const DEFAULT_STORAGE_EXPIRE_KEY = 'storage_expiry'
  const DEFAULT_EXPIRY_DURATION_KEY = 'storage_expiry_duration'

  /**
   * Environment URLs for different services.
   * @type {Object.<string, Object.<string, string>>}
   */
  const ENVIRONMENT_URLS = {
    SQ: {
      local: 'localhost:3000',
      dev_ldt: 'selectquote.outliant.com',
      dev: 'selectquote.outliant.com',
      staging: 'stg-selectquote.outliant.com',
      production: 'selectquote.com',
    },
    LSQ: {
      dev_ldt: 'ldt-selectquote.outliant.com',
      dev: 'life-selectquote.outliant.com',
      staging: 'stg-life-selectquote.outliant.com',
      production: 'life.selectquote.com',
    },
    HAA: {
      dev_ldt: 'homeandauto.outliant.com',
      dev: 'homeandauto.outliant.com',
      staging: 'stg-homeandauto.outliant.com',
      production: 'homeandauto.selectquote.com',
    },
    MSQ: {
      dev_ldt: 'medicare-selectquote.outliant.com',
      dev: 'medicare-selectquote.outliant.com',
      staging: 'stg-medicare-selectquote.outliant.com',
      production: 'medicare.selectquote.com',
    },
    MHL: {
      dev_ldt: 'medicare-helpline.outliant.com',
      dev: 'medicare-helpline.outliant.com',
      staging: 'stg-medicare-helpline.outliant.com',
      production: 'medicarehelpline.com',
    },
    LIS: {
      dev_ldt: 'lifeinsurancesavings.outliant.com',
      dev: 'lifeinsurancesavings.outliant.com',
      staging: 'stg-lifeinsurancesavings.outliant.com',
      production: 'lifeinsurancesavings.com',
    },
    BES: {
      dev_ldt: 'burial-expense.outliant.com',
      dev: 'burial-expense.outliant.com',
      staging: 'stg-burial-expense.outliant.com',
      production: 'burialexpense.com',
    },
  }

  /**
   * Initial configuration for domains with optional siteKey to determine the dynamic domain.
   * The siteKey is used to determine the dynamic domain based on the environment.
   * Assign ONLY domain key per config object to set a static domain not dependent on environment.
   * @type {Array<Object>}
   */
  const DOMAINS_CONFIG = [
    {
      siteKey: 'SQ', // Indicates the dynamic domain based on environment
      seo: { sCode: 'ULMS', nextSCode: 'UUMS' },
      referrer: { sCode: '2UMS', nextSCode: 'UZMS' },
      direct: { sCode: 'UCMS', nextSCode: 'USMS' },
    },
    {
      siteKey: 'LSQ',
      seo: { sCode: 'SNMS', nextSCode: 'UJMS' },
      referrer: { sCode: '1UMS', nextSCode: 'UMMS' },
      direct: { sCode: 'EDMS', nextSCode: 'UKMS' },
    },
    {
      siteKey: 'HAA',
      seo: { sCode: 'SQAHSEO', nextSCode: 'xsseoml' },
      referrer: { sCode: 'SQAHREF', nextSCode: 'xsrefml' },
      direct: { sCode: 'SQAHDE', nextSCode: 'xsdeml' },
    },
    {
      siteKey: 'MSQ',
      seo: { sCode: 'SQSSEO', nextSCode: 'xsseoahl' },
      referrer: { sCode: 'SQSREF', nextSCode: 'xsrefahl' },
      direct: { sCode: 'SQSDE', nextSCode: 'xsdeahl' },
    },
    {
      siteKey: 'MHL',
      seo: { sCode: 'MHLSEO', nextSCode: 'MHLSEO' },
      referrer: { sCode: 'MHLREF', nextSCode: 'MHLREF' },
      direct: { sCode: 'MHLDE', nextSCode: 'MHLDE' },
    },
    {
      siteKey: 'LIS',
      seo: { sCode: 'SRMS', nextSCode: null },
      referrer: { sCode: 'BVMS', nextSCode: null },
      direct: { sCode: 'EHMS', nextSCode: null },
    },
    {
      siteKey: 'BES',
      seo: { sCode: 'SYMS', nextSCode: null },
      referrer: { sCode: 'BZMS', nextSCode: null },
      direct: { sCode: 'EJMS', nextSCode: null },
    },
  ]

  // SQS page-specific keyword mapping for SEO
  const SQS_PAGE_KEYWORD_CONFIG = [
    {
      matchPaths: ['/medicare/medicare-plans/advantage-plans'],
      desktop: { seoKeyword: 'sqsstateadvdesk', phoneNumber: '1-833-703-7236' },
      mobile: { seoKeyword: 'sqsstateadvmob', phoneNumber: '1-844-976-4879' },
    },
    {
      matchPaths: ['/medicare/medicare-plans/supplement-plans'],
      desktop: { seoKeyword: 'sqsstatesuppdesk', phoneNumber: '1-866-785-2413' },
      mobile: { seoKeyword: 'sqsstatesuppmob', phoneNumber: '1-833-333-3956' },
    },
    {
      matchPaths: [
        '/medicare/carriers',
        '/medicare/ancillary-carriers'
      ],
      desktop: { seoKeyword: 'sqscarrierdesk', phoneNumber: '1-833-694-3346' },
      mobile: { seoKeyword: 'sqscarriermob', phoneNumber: '1-888-675-3526' },
    },
    {
      matchPaths: ['/medicare/medicare-enrollment-periods'],
      desktop: { seoKeyword: 'sqsmedenrolldesk', phoneNumber: '1-844-242-1733' },
      mobile: { seoKeyword: 'sqsmedenrollmob', phoneNumber: '1-844-291-9139' },
    },
    {
      matchPaths: ['/medicare/articles'],
      desktop: { seoKeyword: 'sqsartdesk', phoneNumber: '1-866-681-5625' },
      mobile: { seoKeyword: 'sqsartmob', phoneNumber: '1-844-572-9436' },
    },
    {
      matchPaths: [
        '/medicare/additional-coverage',
        '/medicare/faqs',
        '/medicare/government-resources',
        '/medicare/lower-medicare-costs',
        '/medicare/medicare-card',
        '/medicare/medicare-caregiver',
        '/medicare/medicare-changes',
        '/medicare/medicare-checklist',
        '/medicare/medicare-cost',
        '/medicare/medicare-eligibility',
        '/medicare/medicare-employer-coverage',
        '/medicare/medicare-enrollment-periods/when-can-i-enroll-quiz',
        '/medicare/medicare-parts',
        '/medicare/medicare-plans',
        '/medicare/overview',
        '/medicare/resources',
        '/medicare/retirement-and-medicare',
        '/medicare/selectquote-difference',
        '/medicare',
      ],
      desktop: { seoKeyword: 'sqsorgdesk', phoneNumber: '1-844-665-1035' },
      mobile: { seoKeyword: 'sqsorgmob', phoneNumber: '1-833-404-4555' },
    },
  ]

  // MHL page-specific keyword mapping for SEO
  const MHL_PAGE_KEYWORD_CONFIG = [
    {
      matchPaths: ['/medicare-plans/advantage-plans'],
      desktop: {
        seoKeyword: 'mhladvplansdmadesk',
        phoneNumber: '1-877-790-2366',
      },
      mobile: {
        seoKeyword: 'mhladvplansdmamob',
        phoneNumber: '1-877-790-2463',
      },
    },
    {
      matchPaths: [
        '/medicare-plans/supplement-plans',
        '/medicare-plans/prescription-drug-plans',
        '/medicare-plans',
      ],
      desktop: { seoKeyword: 'mhlmedplansdesk', phoneNumber: '1-855-912-2108' },
      mobile: { seoKeyword: 'mhlmedplansmob', phoneNumber: '1-877-790-2343' },
    },
    {
      matchPaths: [
        '/articles/medicare-advantage-plans-pros-cons',
        '/articles/medicare-advantage-open-enrollment-period',
      ],
      desktop: { seoKeyword: 'mhlacqartdesk', phoneNumber: '1-844-678-1115' },
      mobile: { seoKeyword: 'mhlacqartmob', phoneNumber: '1-844-860-6466' },
    },
    {
      matchPaths: ['/articles'],
      desktop: { seoKeyword: 'mhllifedesk', phoneNumber: '1-877-791-3168' },
      mobile: { seoKeyword: 'mhllifemob', phoneNumber: '1-877-832-5183' },
    },
    {
      matchPaths: ['/medicare-enrollment'],
      desktop: {
        seoKeyword: 'mhlmedenrolldesk',
        phoneNumber: '1-877-834-7885',
      },
      mobile: { seoKeyword: 'mhlmedenrollmob', phoneNumber: '1-833-785-7111' },
    },
    {
      matchPaths: ['/medicare-eligibility', '/medicare-coverage'],
      desktop: { seoKeyword: 'mhlmedcovdesk', phoneNumber: '1-877-235-1364' },
      mobile: { seoKeyword: 'mhlmedcovmob', phoneNumber: '1-833-944-1484' },
    },
    {
      matchPaths: ['/', '/faqs'],
      desktop: { seoKeyword: 'mhlproductdesk', phoneNumber: '1-877-505-9845' },
      mobile: { seoKeyword: 'mhlproductmob', phoneNumber: '1-844-703-1247' },
    },
  ]

  /* =============================================================================================
   * Page-Specific SEO sCode Override (MSQ & MHL ONLY)
   * ---------------------------------------------------------------------------------------------
   * Goal: Replace the generic SEO sCodes (SQSSEO / MHLSEO) with page-specific SEO sCodes defined
   *       in SQS_PAGE_KEYWORD_CONFIG & MHL_PAGE_KEYWORD_CONFIG when the user is on a matching path.
   *
   * Rules:
   *   - Limited strictly to MSQ (medicare.* / selectquote.com Medicare sub paths) and MHL domains.
   *   - We ONLY override if current attribution is SEO (base SEO code or already a page-specific
   *     SEO code) or no sCode has been assigned yet. We DO NOT override Direct, Referrer, Paid, or
   *     other preserved campaign codes so other domain logic remains untouched.
   *   - Phone number for the matched path is written into site_session_data.site_campaign_phone.
   *   - The new page-specific sCode becomes the canonical sCode (replacing base SQSSEO/MHLSEO) in
   *     storage and in the URL query param (history.replaceState to avoid extra navigation).
   *   - Other domains (SQ non-medicare, LSQ, HAA, LIS, BES) follow existing logic with zero change.
   *   - Large lists of specific paths can be supported by configuring matchPaths arrays. A match
   *     applies both for an exact path and any deeper nested path when the configured path is a
   *     prefix (e.g. '/articles' matches '/articles/foo').
   *
   * Implementation Outline:
   *   1. Build a quick lookup of all page-level SEO sCodes so getDataByScode can treat them as SEO.
   *   2. Provide helper to detect domain key (MSQ/MHL) from current host (and parent SQ /medicare subtree).
   *   3. Match pathname against config. Choose desktop/mobile variant via viewport width <= 767.
   *   4. Decide whether override is allowed (see rules above). Apply if needed.
   *   5. Update site_session_data JSON (create if missing) with phone number.
   *   6. Update URL query param 'sCode' (in-place) and fire customary internal URL change event.
   *
   * NOTE: We intentionally do NOT push events / dataLayer here per current acceptance criteria.
   * ============================================================================================= */

  /** Collect all page specific SEO codes for fast domain/type classification */
  const PAGE_SPECIFIC_SEO_CODE_DOMAIN = (() => {
    const map = {}
    const add = (domainKey, list) => {
      if (!Array.isArray(list)) return
      list.forEach((entry) => {
        if (!entry) return
        ['desktop', 'mobile'].forEach((variant) => {
          const code = entry?.[variant]?.seoKeyword
          if (code) map[String(code).trim()] = domainKey
        })
      })
    }
    add('MSQ', SQS_PAGE_KEYWORD_CONFIG)
    add('MHL', MHL_PAGE_KEYWORD_CONFIG)
    return map
  })()

  /** Determine MSQ / MHL domainKey from host + path context (parent SQ Medicare subtree counts as MSQ). */
  const getSeoOverrideDomainKey = (host, pathname) => {
    try {
      const sanitizedHost = getSanitizedHost(host)
      const msqHosts = Object.values(ENVIRONMENT_URLS['MSQ'])
      const mhlHosts = Object.values(ENVIRONMENT_URLS['MHL'])
      if (msqHosts.includes(sanitizedHost)) return 'MSQ'
      if (mhlHosts.includes(sanitizedHost)) return 'MHL'
      // If we're on the parent SQ domain and path starts with /medicare treat as MSQ section content
      const parentHosts = Object.values(ENVIRONMENT_URLS['SQ'])
      if (
        parentHosts.includes(sanitizedHost) &&
        pathname.startsWith('/medicare')
      )
        return 'MSQ'
      return null
    } catch {
      return null
    }
  }

  /** Decide desktop vs mobile threshold. */
  const isMobileDevice = () => {
    try {
      if (navigator.userAgentData && typeof navigator.userAgentData.mobile === 'boolean') {
        return navigator.userAgentData.mobile
      }
      const ua = navigator.userAgent || ''
      return /Mobi|Android|iPhone|iPad|iPod/i.test(ua)
    } catch {
      return false
    }
  }

  /**
   * Decide desktop vs mobile.
   * Order:
   *  1. Explicit UA hint / regex
   *  2. Width fallback (<= 767)
   */
  const getViewportDeviceType = () => {
    try {
      if (isMobileDevice()) return 'mobile'
      const w = window.innerWidth || document.documentElement.clientWidth || 0
      return w <= 767 ? 'mobile' : 'desktop'
    } catch {
      return 'desktop'
    }
  }

  /** Match current pathname against configuration list for domainKey supports prefix matching. */
  const resolvePageSeoConfigEntry = (domainKey, pathname) => {
    const list =
      domainKey === 'MSQ'
        ? SQS_PAGE_KEYWORD_CONFIG
        : domainKey === 'MHL'
        ? MHL_PAGE_KEYWORD_CONFIG
        : null
    if (!list) return null
    if (pathname.length > 1 && pathname.endsWith('/'))
      pathname = pathname.slice(0, -1)
    for (const entry of list) {
      const paths = entry?.matchPaths || []
      const matched = paths.some((p) => {
        if (!p) return false
        let testPath = p
        if (testPath.length > 1 && testPath.endsWith('/'))
          testPath = testPath.slice(0, -1)
        return pathname === testPath || pathname.startsWith(testPath + '/')
      })
      if (matched) return entry
    }
    return null
  }

  /**
   * Attempt to override the current sCode with a page-specific SEO code (MSQ/MHL only).
   * Safe no-op when conditions are not met.
   */
  const attemptPageSpecificSeoOverride = (currentDomainHost) => {
    try {
      const url = new URL(window.location.href)
      const pathname = url.pathname
      const domainKey = getSeoOverrideDomainKey(currentDomainHost, pathname)
      if (!domainKey) return // Not MSQ/MHL context exit quickly.

      const device = getViewportDeviceType()
      const entry = resolvePageSeoConfigEntry(domainKey, pathname)
      if (!entry) return // No configured page rule for this path

      const desiredSCode = entry?.[device]?.seoKeyword
      const phoneNumber = entry?.[device]?.phoneNumber
      if (!desiredSCode) return

      // Determine existing attribution state
      const currentSCode =
        getURLVariable('sCode') ||
        getStorage('sCode') ||
        getStorage('domain-tracking-scode')

      // Base SEO sCode for this domain
      const domainEnvHost = getEnvironmentDomain(domainKey)
      const domainData = getDataByDomain(domainEnvHost)
      const baseSeoSCode = domainData?.seo?.sCode

      const isAlreadyPageSpecific =
        currentSCode && PAGE_SPECIFIC_SEO_CODE_DOMAIN[currentSCode]
      // Broaden override: also allow when current sCode is an SEO code belonging to a different domain
      // (foreign SEO) so that cross-domain journeys don't lock in another site's SEO attribution and
      // block page-specific MSQ/MHL codes + phone.
      let isForeignSeo = false
      if (currentSCode && !isAlreadyPageSpecific) {
        try {
          const data = getDataByScode(currentSCode)
          if (data?.type === 'SEO') {
            const currentDomainSanitized = getSanitizedHost(currentDomainHost)
            const sCodeDomainSanitized = data.domain
              ? getSanitizedHost(data.domain)
              : null
            // Foreign if domains differ OR the base SEO doesn't match and it's not the base for this domain
            isForeignSeo =
              Boolean(sCodeDomainSanitized) &&
              sCodeDomainSanitized !== currentDomainSanitized &&
              currentSCode !== baseSeoSCode
          }
        } catch (e) {
          CDTLogger.warn('Foreign SEO evaluation failed', {
            currentSCode,
            error: e?.message,
          })
        }
      }
      const allowOverride =
        !currentSCode ||
        currentSCode === baseSeoSCode ||
        isAlreadyPageSpecific ||
        isForeignSeo
      if (!allowOverride) return // Respect Direct / Referrer / Paid codes

      // If sCode already matches desired page-specific value we may still need to hydrate phone number.
      if (currentSCode === desiredSCode) {
        try {
          const sessionRaw = getStorage('site_session_data')
          const sessionObj = sessionRaw ? JSON.parse(sessionRaw) : {}
            const existingPhone = sessionObj.site_campaign_phone
            if (phoneNumber && existingPhone !== phoneNumber) {
              sessionObj.site_campaign_phone = phoneNumber
              setStorage('site_session_data', JSON.stringify(sessionObj))
            }
        } catch (e) {
          CDTLogger.warn('Failed phone hydration when sCode already matched', e)
        }
        return // Avoid redundant history updates
      }

      CDTLogger.log('Page SEO Override Applied', {
        domainKey,
        pathname,
        device,
        previousSCode: currentSCode,
        newSCode: desiredSCode,
        baseSeoSCode,
        phoneNumber,
      })

      // Persist new sCode
      setScode(desiredSCode)

      // Update site_session_data with phone number (create JSON if absent)
      try {
        const sessionRaw = getStorage('site_session_data')
        const sessionObj = sessionRaw ? JSON.parse(sessionRaw) : {}
        if (phoneNumber && sessionObj.site_campaign_phone !== phoneNumber) {
          sessionObj.site_campaign_phone = phoneNumber
        }
        setStorage('site_session_data', JSON.stringify(sessionObj))
      } catch (err) {
        CDTLogger.warn(
          'Failed to update site_session_data.site_campaign_phone',
          err
        )
      }

      // In-place URL mutation to reflect updated sCode (same-host only scenario assumed here)
      const updated = setURLVariable(
        'sCode',
        desiredSCode,
        window.location.href
      )
      if (updated !== window.location.href) {
        history.replaceState(null, '', updated)
        // We intentionally do NOT dispatch custom event or dataLayer push per current requirements.
      }
    } catch (error) {
      CDTErrorHandler(error, 'attemptPageSpecificSeoOverride')
    }
  }

  /* ____________________________________ Custom Logger and Error Handler ____________________________________ */

  /**
   * Stringify an object with circular references by using a WeakSet to keep track of seen objects.
   * @param {any} args - The object to stringify.
   * @returns {string} - The stringified object with circular references handled.
   */
  const stringifyCircular = (args) => {
    const seen = new WeakSet()
    try {
      return JSON.stringify(
        args,
        (key, value) => {
          if (typeof value === 'object' && value !== null) {
            if (seen.has(value)) return // Circular reference found
            seen.add(value)
          }
          return value
        },
        2
      )
    } catch (err) {
      return '[Unserializable object]'
    }
  }

  /**
   * Object containing debug settings for Cross Domain Tracking.
   * @type {Object}
   */
  const CDT_DEBUG = {
    enabled: false, // Triage CDT bug
    /**
     * Sets the debug mode.
     * @param {boolean} value - The value to set the debug mode to.
     * @returns {void}
     */
    setDebug: (value) => {
      CDT_DEBUG.enabled = value
      console.log(
        `CDT v${CROSS_DOMAIN_TRACKING_VERSION} Debug mode: ${
          value ? 'enabled' : 'disabled'
        }`
      )
      setStorage('cdt_debug', value.toString())
    },
  }

  /**
   * CDTLogger object with methods for logging messages with different severity levels.
   * @namespace
   */
  const CDTLogger = {
    /**
     * Logs a message if debug mode is enabled.
     * @param {string} message - The message to log.
     * @param {...*} args - Additional arguments to log with the message.
     */
    log(message, ...args) {
      if (CDT_DEBUG.enabled) {
        const caller = this.getCaller()
        console.log(
          `[CDT INFO v${CROSS_DOMAIN_TRACKING_VERSION}] ${caller}: ${message}    \n`,
          stringifyCircular(filterUnsafeArgs(args))
        )
      }
    },
    /**
     * Logs a warning message if debug mode is enabled.
     * @param {string} message - The warning message to log.
     * @param {...*} args - Additional arguments to log with the message.
     */
    warn(message, ...args) {
      const caller = this.getCaller()
      console.warn(
        `[CDT WARNING v${CROSS_DOMAIN_TRACKING_VERSION}] ${caller}: ${message}    \n`,
        stringifyCircular(filterUnsafeArgs(args))
      )
    },
    /**
     * Logs an error message.
     * @param {string} message - The error message to log.
     * @param {...*} args - Additional arguments to log with the message.
     */
    error(message, ...args) {
      const caller = this.getCaller()
      console.error(
        `[CDT Error v${CROSS_DOMAIN_TRACKING_VERSION}] ${caller}: ${message}    \n`,
        ...args
      )
    },
    /**
     * Logs a message with a stack trace if debug mode is enabled.
     * @param {string} message - The message to log.
     * @param {...*} args - Additional arguments to log with the message.
     */
    trace(message, ...args) {
      if (CDT_DEBUG.enabled) {
        const caller = this.getCaller()
        console.trace(
          `%c[CDT Trace v${CROSS_DOMAIN_TRACKING_VERSION}] ${caller}: ${message}`,
          genHexShade('#9E9E9E', caller),
          ...args
        )
      }
    },

    /**
     * Gets the name of the calling function.
     * @returns {string} The name of the calling function or 'Unknown' if not found.
     * @private
     */
    getCaller() {
      try {
        const error = new Error()
        const stack = error.stack.split('\n')
        const callerLine = stack[3] || stack[2]
        const callerMatch = callerLine.match(/at (\S+)/)
        return callerMatch ? callerMatch[1] : 'Unknown'
      } catch {
        return 'Unknown'
      }
    },
  }

  /**
   * Handles errors by logging the error message and stack trace using CDTLogger.
   * @param {Error} error - The error object that occurred.
   * @param {string} functionName - The name of the function where the error occurred.
   */
  const CDTErrorHandler = (error, functionName) => {
    CDTLogger.error(`Error in ${functionName}:`, error)
    CDTLogger.error('Stack trace:', error.stack)
  }

  /* ______________________________________ URL Utilities ______________________________________ */

  /**
   * Checks if the current window location host includes 'localhost'.
   * @returns {boolean} True if the host includes 'localhost', false otherwise.
   */
  const isLocalEnv = () => window.location.host.includes('localhost')
  /**
   * Gets the TTL expiry override from URL parameters, checking hours, minutes, and seconds.
   * Cached for performance - only calculates once per page load.
   * Also stores the duration in localStorage for persistence.
   * @param {number} defaultTtl - The default TTL value to use if no override is found
   * @returns {number} The TTL expiry value in milliseconds
   */
  const getTtlExpiryOverride = (() => {
    let cachedOverride = null

    return (defaultTtl = DEFAULT_TTL_EXPIRY) => {
      const urlParams = new URLSearchParams(window.location.search)
      const baseKey = DEFAULT_STORAGE_EXPIRE_KEY
      const msHours = 1000 * 60 * 60
      const msMinutes = 1000 * 60
      const msSeconds = 1000

      // Config: priority order with multipliers
      const overrideConfig = {
        [`${baseKey}_hrs`]: msHours,
        [`${baseKey}_mins`]: msMinutes,
        [`${baseKey}_secs`]: msSeconds,
      }

      // Check for URL parameter overrides first
      const urlOverride = Object.entries(overrideConfig).reduce(
        (result, [param, multiplier]) => {
          if (result !== null) return result // Already found valid override

          const value = parseInt(urlParams.get(param))
          return !isNaN(value) && value > 0 ? value * multiplier : null
        },
        null
      )

      if (urlOverride !== null) {
        // URL override found - always use it and update stored values
        cachedOverride = urlOverride
        localStorage.setItem(DEFAULT_EXPIRY_DURATION_KEY, cachedOverride.toString())
        // Also update the current expiry timestamp
        const currentDate = Date.now()
        localStorage.setItem(DEFAULT_STORAGE_EXPIRE_KEY, (currentDate + cachedOverride).toString())
      } else if (cachedOverride !== null) {
        // Return cached value if no URL override and we have a cached value
        return cachedOverride
      } else {
        // No URL override and no cached value - check for stored duration, fallback to default
        const storedDuration = localStorage.getItem(DEFAULT_EXPIRY_DURATION_KEY)
        cachedOverride = storedDuration ? parseInt(storedDuration) : defaultTtl

        // Store the latest duration
        localStorage.setItem(DEFAULT_EXPIRY_DURATION_KEY, cachedOverride.toString())
      }

      return cachedOverride
    }
  })()

  /**
   * Sets a value in both sessionStorage and localStorage with the given key.
   * This ensures data persistence across both session and local storage contexts.
   * By default uses type='both' to store in both session and local storage.
   * @param {string} key - The key to store the value under
   * @param {string} value - The value to store
   * @param {('both'|'session'|'local')} [type='both'] - The type of storage to set the value in
   */
  const setStorage = (key, value, type = 'both') => {
    const currentExpiry = localStorage.getItem(DEFAULT_STORAGE_EXPIRE_KEY)
    const currentDate = Date.now()

    if (!currentExpiry || currentExpiry < currentDate) {
      const ttlExpiryOverride = getTtlExpiryOverride(DEFAULT_TTL_EXPIRY)
      localStorage.setItem(
        DEFAULT_STORAGE_EXPIRE_KEY,
        currentDate + ttlExpiryOverride
      )
    }

    if (type === 'both') {
      sessionStorage.setItem(key, value)
      localStorage.setItem(key, value)
    } else if (type === 'session') {
      sessionStorage.setItem(key, value)
    } else if (type === 'local') {
      localStorage.setItem(key, value)
    }
  }

  /**
   * Retrieves a value from storage by checking sessionStorage first, then falling back to localStorage.
   * By default uses type='both' to check both session and local storage.
   * @param {string} key - The key to retrieve the value for
   * @param {('both'|'session'|'local')} [type='both'] - The type of storage to set the value in
   * @returns {string|null} The stored value if found in either storage, or null if not found
   */
  const getStorage = (key, type = 'both') => {
    const storedValue =
      type === 'both'
        ? sessionStorage.getItem(key) || localStorage.getItem(key)
        : type === 'session'
        ? sessionStorage.getItem(key)
        : localStorage.getItem(key)
    const storageExpiry = localStorage.getItem(DEFAULT_STORAGE_EXPIRE_KEY)
    const isExpired = storageExpiry && storageExpiry < Date.now()
    return storedValue && !isExpired ? storedValue : null
  }

  /**
   * Dynamically retrieves the domain for the specified key based on the current environment and domain configuration.
   * @param {string} key - The key to retrieve the domain for.
   * @returns {string|null} The domain for the specified key in the current environment, or null if not found.
   */
  const getEnvironmentDomain = (key) => {
    try {
      let environment = 'production'
      const host = window.location.host
      const isOutliant = host.includes('outliant')
      const isStaging = host.includes('stg')
      const isDev = isOutliant && !isStaging
      const isDevLDT = isOutliant && host.includes('ldt-')
      const isLocal = isLocalEnv() && key === 'SQ'

      if (isLocal) environment = 'local'
      else if (isDevLDT) environment = 'dev_ldt'
      else if (isDev) environment = 'dev'
      else if (isStaging) environment = 'staging'

      return ENVIRONMENT_URLS[key]?.[environment] ?? null
    } catch (error) {
      CDTErrorHandler(error, 'getEnvironmentDomain')
      return null
    }
  }

  // Map domains with their configurations
  const MAPPED_DOMAINS = DOMAINS_CONFIG.map((config) => {
    if (config.siteKey) {
      return {
        ...config,
        domain: getEnvironmentDomain(config.siteKey),
        domains: Object.values(ENVIRONMENT_URLS[config.siteKey]),
      }
    }
    return config
  })

  const SUPPORTED_DOMAINS = MAPPED_DOMAINS.flatMap((item) => item.domains)
  // Set of base origin sCodes (initial SEO/REFERRER/DIRECT values) used to decide if a page-level keyword can override
  const BASE_SCODES = new Set(
    DOMAINS_CONFIG.flatMap((c) => [c.seo?.sCode, c.referrer?.sCode, c.direct?.sCode].filter(Boolean))
  )

  /**
   * Checks if the pathname of a given URL starts with a specified path.
   * @param {string} path - The path to check against.
   * @param {string} url - The URL to check.
   * @returns {boolean} True if the URL pathname starts with the specified path, false otherwise.
   */
  const urlPathStartsWith = (path, url) => {
    const newUrl = new URL(url)
    return newUrl.pathname.startsWith(path)
  }

  /**
   * Retrieves a specific variable from the URL query parameters (case-insensitive).
   * If the variable is not found, it returns null.
   * @param {string} variable - The variable to retrieve from the URL.
   * @param {string} [url=window.location.href] - The URL to search for the variable.
   * @returns {string|null} The value of the variable if found, otherwise null.
   */
  const getURLVariable = (variable, url = window.location.href) => {
    try {
      const parsedUrl = new URL(url)
      const queryParams = new URLSearchParams(parsedUrl.search)
      const params = new URLSearchParams()

      for (const [key, value] of queryParams) {
        params.append(key.toLowerCase(), value)
      }

      return params.get(variable.toLowerCase())
    } catch (error) {
      CDTErrorHandler(error, 'getURLVariable')
      return null
    }
  }

  /**
   * Merges URL query parameters with the given variables and returns the updated URL.
   * @param {string} url - The original URL to merge with variables.
   * @param {string} variables - The variables to merge into the URL query parameters.
   * @returns {string} The updated URL with merged query parameters.
   */
  const mergeUrlWithVariables = (url, variables) => {
    try {
      if (!variables) return url

      const parsedUrl = new URL(url)
      const query = new URLSearchParams(parsedUrl.search)
      const newVariables = new URLSearchParams(variables)

      newVariables.forEach((value, key) => {
        query.set(key, value)
      })

      parsedUrl.search = query.toString()
      return parsedUrl.href
    } catch (error) {
      CDTErrorHandler(error, 'mergeUrlWithVariables')
      return url
    }
  }

  /**
   * Sets a variable in the URL query parameters to a specified value.
   * If the URL is not provided, it defaults to the current window location.
   * @param {string} variable - The variable to set in the URL.
   * @param {string} value - The value to assign to the variable.
   * @param {string} [url=window.location.href] - The URL in which to set the variable.
   * @returns {string} The updated URL with the variable set to the specified value.
   */
  const setURLVariable = (variable, value, url = window.location.href) => {
    try {
      const parsedUrl = new URL(url)
      const query = new URLSearchParams(parsedUrl.search)
      if (value) query.set(variable, value)
      parsedUrl.search = query.toString()
      return parsedUrl.href
    } catch (error) {
      CDTErrorHandler(error, 'setURLVariable')
      return url
    }
  }

  /**
   * Checks if a given string is a valid URL.
   * @param {string} string - The string to check if it is a valid URL.
   * @returns {boolean} True if the string is a valid URL, false otherwise.
   */
  const isValidUrl = (string) => {
    try {
      new URL(string)
      return true
    } catch {
      return false
    }
  }

  /**
   * Sanitizes the given URL by removing the protocol and www subdomain if present.
   * If the URL does not start with 'http', 'https', or 'localhost', it prepends 'https://' to the URL.
   * @param {string} url - The URL to sanitize.
   * @returns {string} The sanitized URL.
   */
  const getSanitizedURL = (url) => {
    try {
      const isLocal = url.startsWith('localhost')
      const isTel = url.startsWith('tel:')
      const isHttp = url.startsWith('http')
      const formattedUrl = isLocal
        ? `http://${url}`
        : isTel
        ? url
        : !isHttp
        ? `https://${url}`
        : url
      return formattedUrl.replace('www.', '')
    } catch (error) {
      CDTErrorHandler(error, 'getSanitizedURL')
      return url
    }
  }

  /**
   * Sanitizes the given URL string by removing 'www.' and extracting the hostname.
   * @param {string} targetHref - The URL to be sanitized.
   * @returns {string} The sanitized hostname extracted from the URL.
   */
  const getSanitizedHost = (targetHref) => {
    try {
      const sanitizedURL = getSanitizedURL(targetHref)
      if (!isValidUrl(sanitizedURL)) {
        CDTLogger.error(
          'getSanitizedHost Error - Invalid URL provided:',
          targetHref
        )
        return sanitizedURL
      }
      const url = new URL(sanitizedURL)
      return sanitizedURL.includes('localhost') ? url.host : url.hostname
    } catch (error) {
      CDTErrorHandler(error, 'getSanitizedHost')
      return getSanitizedURL(targetHref)
    }
  }

  /**
   * Logs the changes between the old and new URLs, including parameter changes.
   * @param {URL} oldUrl - The old URL object.
   * @param {URL} newUrl - The new URL object.
   */
  const logUrlChange = (oldUrl, newUrl) => {
    if (!CDT_DEBUG.enabled) return

    const oldParams = new URLSearchParams(oldUrl.search)
    const newParams = new URLSearchParams(newUrl.search)
    const allKeys = new Set([...oldParams.keys(), ...newParams.keys()])

    const tableData = {}
    allKeys.forEach((key) => {
      const oldValue = oldParams.get(key)
      const newValue = newParams.get(key)
      let status = 'Unchanged'
      if (!oldValue && newValue) status = 'Added'
      else if (oldValue && !newValue) status = 'Removed'
      else if (oldValue !== newValue) status = 'Changed'

      tableData[key] = {
        Status: status,
        'New Value': newValue || '(not set)',
        'Old Value': oldValue || '(not set)',
      }
    })

    console.group('URL Change Detection')
    console.log('%cURL Changes:', 'font-weight: bold; font-size: 14px;')
    console.log(
      '%c Old URL: ',
      'background-color:#ffbb00; color: white;',
      oldUrl.href
    )
    console.log(
      '%c New URL: ',
      'background-color:#12b300; color: white;',
      newUrl.href
    )
    console.log('%cParameter Changes:', 'font-weight: bold; font-size: 14px;')
    console.table(tableData)
    console.groupEnd()
  }

  /* ______________________________________ Redirect Utilities ______________________________________ */

  /**
   * Handles redirects on the page when a user clicks on a link.
   * @param {string} currentDomain - The current domain of the page.
   */
  const handleAllRedirects = (currentDomain) => {
    try {
      document.body.addEventListener('click', (event) => {
        let targetElement = event.target
        while (
          targetElement &&
          targetElement.tagName.toLowerCase() !== 'a' &&
          targetElement !== document.body
        ) {
          targetElement = targetElement.parentNode
        }
        if (targetElement && targetElement.tagName.toLowerCase() === 'a') {
          const href = targetElement.getAttribute('href')
          if (!href) return

          // Check if link is from AddSearch
          const isAddSearchLink = targetElement.hasAttribute(
            'data-analytics-click'
          )

          // Check if the link is set to open in a new tab
          const isNewTab =
            targetElement.getAttribute('target') === '_blank' ||
            event.ctrlKey ||
            event.metaKey

          // Handle relative URLs and anchor links
          const fullUrl = new URL(href, window.location.origin)
          const urlHost = getSanitizedHost(fullUrl.href)

          if (
            (SUPPORTED_DOMAINS.includes(urlHost) ||
              urlHost === currentDomain) &&
            !isNewTab
          ) {
            event.preventDefault()
            CDTLogger.log('handleAllRedirects - Prevented default redirect', {
              currentDomain,
              supportedDomains: SUPPORTED_DOMAINS,
              isSupportedDomain: SUPPORTED_DOMAINS.includes(urlHost),
              urlHost,
              isNewTab,
              isAddSearchLink,
              href: fullUrl.href,
            })
            redirectWithParams(currentDomain, fullUrl.href, isAddSearchLink)
          } else {
            CDTLogger.log('handleAllRedirects - Allowing default behavior', {
              urlHost,
              isNewTab,
              isAddSearchLink,
              SUPPORTED_DOMAINS,
            })
          }
        }
      })
    } catch (error) {
      CDTErrorHandler(error, 'handleAllRedirects')
    }
  }

  /**
   * Redirects to a new URL with parameters based on the current domain and URL.
   * This function handles both internal and external redirects, preserves Google Ads parameters,
   * and ensures proper execution timing with respect to Google Tag Manager (GTM) and Next.js routing.
   * @param {string} currentDomain - The current domain of the website.
   * @param {string} url - The URL to redirect to.
   * @returns {Promise<void>}
   */
  const redirectWithParams = async (
    currentDomain,
    url,
    isAddSearchLink = false
  ) => {
    try {
      const isNextJs = Boolean(window?.next)
      let newUrlString = mergeUrlWithVariables(
        url,
        getStorage('domain-tracking-url-variables')
      )

      const haaDomain = getEnvironmentDomain('HAA')
      const lsqDomain = getEnvironmentDomain('LSQ')
      const msqDomain = getEnvironmentDomain('MSQ')
      const parentDomain = getEnvironmentDomain('SQ')

      const siteSessionData = getStorage('site_session_data')
      const firstURL = getStorage('firstURL')
      if (siteSessionData) {
        const siteSession = JSON.parse(siteSessionData)
        newUrlString = setURLVariable(
          'pass_sid',
          siteSession.site_session_id,
          newUrlString
        )
      }

      if (firstURL) {
        newUrlString = setURLVariable('first_url', firstURL, newUrlString)
      }

      // MWD-2310, Only send `pass_lp` when going from SQ â†’ LSQ
      const fromDomain = getSanitizedHost(window.location.href)
      const toDomain = getSanitizedHost(newUrlString)
      const sqDomains = Object.values(ENVIRONMENT_URLS['SQ'])
      const lsqDomains = Object.values(ENVIRONMENT_URLS['LSQ'])

      const isSQtoLSQ =
        sqDomains.includes(fromDomain) && lsqDomains.includes(toDomain)

      if (isSQtoLSQ) {
        const passLp = getStorage('pass_lp')
        if (passLp) {
          newUrlString = setURLVariable('pass_lp', passLp, newUrlString)
          CDTLogger.log('Evaluated isSQtoLSQ condition', {
            fromDomain,
            toDomain,
            isSQtoLSQ,
            passLp,
          })
        }
      }

      const canvasID = getStorage('domain-tracking-canvas')
      let sCode =
        getURLVariable('sCode', newUrlString) ||
        getStorage('domain-tracking-scode') ||
        getStorage('sCode')

      let urlHostName = getSanitizedHost(url)
      const newUrl = new URL(newUrlString)
      const parentDomains = Object.values(ENVIRONMENT_URLS['SQ'])
      const isParentDomain = parentDomains.includes(urlHostName)
      const isHaaPath = urlPathStartsWith('/auto-and-home-insurance', url)
      const isLsqPath = urlPathStartsWith('/life-insurance', url)
      const isMsqPath = urlPathStartsWith('/medicare', url)
      newUrlString = setURLVariable('pass_cid', canvasID, newUrlString)

      // Update url host on SQ.com Prod pages for HAA/LSQ/MSQ site content redirects
      // ! NOTE: Prod is deployed with separate Contentful Content Spaces for HAA/LSQ/MSQ articles
      // !       /quote-form pages are deployed with separate Next.js apps for HAA/LSQ/MSQ
      if (isParentDomain) {
        if (isHaaPath) urlHostName = haaDomain
        if (isLsqPath) urlHostName = lsqDomain
        if (isMsqPath) urlHostName = msqDomain
      }

      if (!sCode) {
        // fallback: getScodeByOrigin or static default
        sCode = getScodeByOrigin(urlHostName, 'DIRECT') || 'UCMS'
        CDTLogger.warn(`sCode missing, using fallback: ${sCode}`, {
          sCode,
          urlHostName,
          newUrlString,
        })
        setScode(sCode)
      }

      if (sCode && typeof sCode === 'string') {
        const sCodeByHistory = await getScodeByHistory(
          currentDomain,
          urlHostName,
          sCode
        )
        newUrlString = setURLVariable('sCode', sCodeByHistory, newUrlString)
        CDTLogger.log('sCodeByHistory', { sCodeByHistory, sCode, urlHostName })
      }

      // Bridge campaign phone across domains via pass_phone parameter
      try {
        const sessionDataRaw = getStorage('site_session_data')
        if (sessionDataRaw) {
          const sessionData = JSON.parse(sessionDataRaw)
          const phone = sessionData.site_campaign_phone
          if (phone) {
            // Scope: only append when (from or to) domain is MSQ or MHL OR current path starts with /medicare
            const fromDomain = getSanitizedHost(window.location.href)
            const toDomain = getSanitizedHost(newUrlString)
            const msqDomains = Object.values(ENVIRONMENT_URLS['MSQ'])
            const mhlDomains = Object.values(ENVIRONMENT_URLS['MHL'])
            const pathIsMedicare = /^\/medicare(\/|-|$)/i.test(window.location.pathname)
            const isMedicareContext =
              pathIsMedicare ||
              msqDomains.includes(fromDomain) ||
              msqDomains.includes(toDomain) ||
              mhlDomains.includes(fromDomain) ||
              mhlDomains.includes(toDomain)
            if (isMedicareContext) {
              newUrlString = setURLVariable('pass_phone', encodeURIComponent(phone), newUrlString)
            }
          }
        }
      } catch (e) {
        CDTLogger.warn('Failed adding pass_phone', e)
      }

      const urlParts = new URL(newUrlString)
      urlParts.pathname = urlParts.pathname.replace(/\/$/, '')
      newUrlString = urlParts.href
      const windowUrl = window.location.href.replace('www.', '')
      const currentUrl = new URL(windowUrl)
      const currentPath = currentUrl.pathname
      const isAnchor = newUrlString.includes('#')
      const newUrlHost = new URL(newUrl)?.host ?? ''
      const isSameHost = newUrlHost === currentUrl?.host
      const isSamePath = currentPath === urlParts.pathname
      const isSamePage = isSameHost && isSamePath
      const isSamePageAnchor = isAnchor || isSamePage

      CDTLogger.log('Initial Params Check', {
        args: { currentDomain, url },
        sCode,
        urlInfo: {
          urlParts,
          urlHostName,
          newUrl,
          newUrlString,
          windowUrl,
          currentUrl,
          currentPath,
        },
        domainChecks: {
          isHaaPath,
          isLsqPath,
          isMsqPath,
          isParentDomain,
        },
        parentDomains,
        isAnchor,
        isSamePageAnchor,
        pageMatchCheck: {
          isSameHost,
          isSamePath,
          isSamePage,
          currentPath,
          urlPartsPath: urlParts.pathname,
        },
        willRunUpdateUrl: newUrlString !== window.location.href,
        env: {
          currentDomain,
          parentDomain,
          msqDomain,
          lsqDomain,
          haaDomain,
        },
      })

      // Handle scrolling into view anchor links on the same page (i.e. /ex -> /ex#section)
      if (isSamePageAnchor) {
        document.getElementById(urlParts.hash.substring(1))?.scrollIntoView()
        return
      }

      if (newUrlString !== window.location.href) {
        const newDomain = getSanitizedHost(newUrlString)
        const windowDomain = getSanitizedHost(window.location.href)
        const isExternalDomain = newDomain !== windowDomain

        CDTLogger.log('Internal/External Domain Check', {
          currentDomain,
          windowDomain,
          newDomain,
          isExternalDomain,
          isNextJs,
          isAddSearchLink,
        })

        /**
         * Updates the URL, preserving Google Ads parameters and handling both internal and external redirects.
         */
        const updateUrl = () => {
          try {
            const oldUrl = new URL(window.location.href)
            const updatedUrl = new URL(newUrlString, window.location.origin)

            logUrlChange(oldUrl, updatedUrl)

            if (!newUrlString.includes('sCode')) {
              CDTLogger.warn(
                `sCode (${sCode}) not found in URL: ${newUrlString}`,
                { newUrlString, sCode, urlHostName, currentDomain }
              )
              throw new Error(`sCode not found in URL: ${newUrlString}`)
            }

            if (isExternalDomain) {
              CDTLogger.log('External Domain Redirect', {
                newUrlString,
                isNextJs,
              })
              window.location.href = newUrlString
            } else {
              CDTLogger.log('Internal Domain Update', {
                newUrlString,
                isNextJs,
              })
              if (isNextJs) {
                window?.next?.router?.replace(newUrlString)
              } else {
                window.history.replaceState(null, '', newUrlString)
              }
              window.dispatchEvent(new Event('cdtUrlChange'))
            }
          } catch (error) {
            CDTErrorHandler(error, 'redirectWithParams - updateUrl')
            console.trace(error)
          }
        }

        /**
         * Waits for Google Tag Manager to load before executing the URL update.
         */
        const waitForGTMAndExecute = () => {
          let attempts = 0
          const maxAttempts = 100
          const checkInterval = 5 // ms

          const checkGTMAndExecute = () => {
            CDTLogger.log('Checking GTM and executing updateUrl', {
              attempts,
              maxAttempts,
              checkInterval,
              dataLayer: window.dataLayer,
            })
            if (attempts >= maxAttempts) {
              CDTLogger.warn(
                'Max attempts reached waiting for GTM. Executing updateUrl.'
              )
              updateUrl()
              return
            }

            if (window.dataLayer) {
              requestAnimationFrame(() => {
                CDTLogger.log('GTM Loaded. Executing updateUrl.')
                updateUrl()
              })
            } else {
              attempts++
              setTimeout(checkGTMAndExecute, checkInterval)
            }
          }

          checkGTMAndExecute()
        }

        if (isNextJs && !isExternalDomain && !isAddSearchLink) {
          CDTLogger.log('Next.js Route Change Handler', {
            isNextAndInternal: isNextJs && !isExternalDomain,
            isAddSearchLink,
          })
          const routeChangeHandler = () => {
            CDTLogger.log('routeChangeHandler Start', {})
            window.removeEventListener(
              'nextjsRouteChangeComplete',
              routeChangeHandler
            )
            waitForGTMAndExecute()
          }
          window.addEventListener(
            'nextjsRouteChangeComplete',
            routeChangeHandler
          )
        } else {
          CDTLogger.log('Non-Next.js Route Change Handler', {
            isNextJs,
            isExternalDomain,
            isAddSearchLink,
          })
          waitForGTMAndExecute()
        }
      } else {
        CDTLogger.warn(
          'redirectWithParams - URLs are the same, no update needed',
          {
            url,
            currentUrl: window.location.href,
            currentDomain,
            newUrlString,
            isParentDomain,
            isSamePageAnchor,
            willRunUpdateUrl: newUrlString !== window.location.href,
          }
        )
      }
    } catch (error) {
      CDTErrorHandler(error, 'redirectWithParams')
      window.removeEventListener('nextjsRouteChangeComplete', () => {})
    }
  }

  /* ______________________________________ SCode Functions ______________________________________ */

  /** A Map object used to cache campaign data. */
  const campaignCache = new Map()

  /**
   * Asynchronously fetches campaign data from a specified URL.
   * @param {string} sCode - The campaign code used to fetch data.
   * @returns {Object | null} The first campaign data object if successful, otherwise null.
   */
  const getCampaign = async (sCode) => {
    const campaignCentralLambdaUrl = `https://d9fs82ix42pq1.cloudfront.net/dev/sqcmp1/get_campaigns_table_csv?campaignKey=${sCode}`
    try {
      if (campaignCache && campaignCache.has(sCode)) {
        return campaignCache.get(sCode)
      }

      // Check if sCode is provided
      if (!sCode || typeof sCode !== 'string')
        throw new Error('sCode is required')

      const response = await fetch(campaignCentralLambdaUrl)
      if (!response.ok) return null
      const data = await response.json()
      const campaignData = data && data.length > 0 ? data[0] : null

      campaignCache.set(sCode, campaignData)

      return campaignData
    } catch (error) {
      // Format variables to avoid FullStory redaction
      console.error(
        `[CDT Error v${CROSS_DOMAIN_TRACKING_VERSION}] getCampaign error: sCode Check`,
        {
          's-C-o-d-e': sCode
            ? typeof sCode === 'string'
              ? sCode.split('').join(' ')
              : String(sCode)
            : null,
          endpoint: campaignCentralLambdaUrl
            ? campaignCentralLambdaUrl.split('?')[0] + '?...'
            : null,
        }
      )
      CDTErrorHandler(error, 'getCampaign')

      return null
    }
  }
  /**
   * Retrieves the site ID based on the domain provided.
   * @param {string} domain - The domain for which to retrieve the site ID.
   * @returns {string|null} The site ID corresponding to the domain, or null if no match is found.
   */
  const getSiteId = (domain) => {
    try {
      const domainHost = getSanitizedHost(domain)
      const haaDomain = getEnvironmentDomain('HAA')
      const lsqDomain = getEnvironmentDomain('LSQ')
      const msqDomain = getEnvironmentDomain('MSQ')
      const homeDomain = getEnvironmentDomain('SQ')

      switch (domainHost) {
        case msqDomain:
          return 'MSQ'
        case lsqDomain:
          return 'LSQ'
        case haaDomain:
          return 'HSQ'
        case homeDomain:
          return 'BSQ'
        default:
          return null
      }
    } catch (error) {
      CDTErrorHandler(error, 'getSiteId')
      return null
    }
  }

  /**
   * Retrieves the sCode based on the domain and origin provided.
   * @param {string} domain - The domain to retrieve data for.
   * @param {string} origin - The origin type (DIRECT, SEO, REFERRER).
   * @returns {string|null} The sCode corresponding to the domain and origin, or null if not found.
   */
  const getScodeByOrigin = (domain, origin) => {
    try {
      const dataByDomain = getDataByDomain(domain)
      if (dataByDomain === undefined) {
        return null
      }
      switch (origin) {
        case 'DIRECT':
          return dataByDomain.direct.sCode
        case 'SEO':
          return dataByDomain.seo.sCode
        case 'REFERRER':
          return dataByDomain.referrer.sCode
        default:
          return null
      }
    } catch (error) {
      CDTErrorHandler(error, 'getScodeByOrigin')
      return null
    }
  }

  /**
   * Retrieves data based on the provided sCode.
   * @param {string} sCode - The sCode to search for in the mapped domains.
   * @returns {Object} An object containing domain, sCode, and type of the sCode.
   */
  const getDataByScode = (sCode) => {
    try {
      const seoMapped = MAPPED_DOMAINS.find(
        (x) => x.seo.sCode === sCode || x.seo.nextSCode === sCode
      )
      const referrerMapped = MAPPED_DOMAINS.find(
        (x) => x.referrer.sCode === sCode || x.referrer.nextSCode === sCode
      )
      const directMapped = MAPPED_DOMAINS.find(
        (x) => x.direct.sCode === sCode || x.direct.nextSCode === sCode
      )

      // Page-specific SEO codes mapping (MSQ/MHL) so they are treated as SEO in chaining
      let pageSpecificSeoDomain = null
      if (!seoMapped && PAGE_SPECIFIC_SEO_CODE_DOMAIN[sCode]) {
        const key = PAGE_SPECIFIC_SEO_CODE_DOMAIN[sCode]
        pageSpecificSeoDomain = getEnvironmentDomain(key)
      }

      const domain =
        seoMapped?.domain ||
        pageSpecificSeoDomain ||
        referrerMapped?.domain ||
        directMapped?.domain
      const sCodeType =
        seoMapped || pageSpecificSeoDomain
          ? 'SEO'
          : referrerMapped
          ? 'REFERRER'
          : directMapped
          ? 'DIRECT'
          : null

      const sCodeResult = { domain, sCode, type: sCodeType }
      CDTLogger.log('sCode values', {
        ...sCodeResult,
        mappedResults: {
          seoMapped,
          pageSpecificSeoDomain,
          referrerMapped,
          directMapped,
        },
      })
      return sCodeResult
    } catch (error) {
      CDTErrorHandler(error, 'getDataByScode')
      return null
    }
  }

  /**
   * Retrieves the next sCode based on the history and current domain information.
   * @param {string} currentDomain - The current domain of the page.
   * @param {string} domain - The domain to retrieve data for.
   * @param {string} currentScode - The current sCode value.
   * @returns {Promise<string>} The next sCode value based on the history and domain data.
   */
  const getScodeByHistory = async (currentDomain, domain, currentScode) => {
    try {
      currentDomain = getSanitizedHost(currentDomain)
      domain = getSanitizedHost(domain)
      const sCodeObj = getDataByScode(currentScode)
      const domainData = getDataByDomain(domain)
      const parentDomain = getEnvironmentDomain('SQ')
      const msqDomain = getEnvironmentDomain('MSQ')
      const lsqDomain = getEnvironmentDomain('LSQ')
      const haaDomain = getEnvironmentDomain('HAA')

      const hasUrlCid = Boolean(getURLVariable('cid'))
      const toMedicare =
        hasUrlCid &&
        domain === msqDomain &&
        [lsqDomain, haaDomain, parentDomain].includes(currentDomain)
      const toLife =
        hasUrlCid &&
        domain === lsqDomain &&
        [msqDomain, haaDomain, parentDomain].includes(currentDomain)
      const toHomeAndAuto =
        hasUrlCid &&
        domain === haaDomain &&
        [msqDomain, lsqDomain, parentDomain].includes(currentDomain)
      const toParentDomain =
        hasUrlCid &&
        domain === parentDomain &&
        [msqDomain, lsqDomain, haaDomain, parentDomain].includes(currentDomain)

      const campaignData = await getCampaign(currentScode)
      const siteId = getSiteId(domain)
      const keepCampaignKey = campaignData
        ? campaignData['Category']?.includes('Paid') &&
          campaignData['Site ID']?.includes(siteId)
        : false

      const logObj = {
        currentScode,
        sCodeObj,
        siteId,
        hasUrlCid,
        keepCampaignKey,
        campaignData,
        domains: {
          msqDomain,
          lsqDomain,
          haaDomain,
          parentDomain,
          currentDomain,
          domain,
        },
        toEnv: { toMedicare, toLife, toHomeAndAuto, toParentDomain },
      }
      CDTLogger.log('check', logObj)

      if (toMedicare) {
        const toMedicareScode = keepCampaignKey ? currentScode : 'xspaidahl'
        CDTLogger.log('toMedicare', { finalSCode: toMedicareScode, ...logObj })
        return toMedicareScode
      }

      if (toLife) {
        const toLifeScode = keepCampaignKey ? currentScode : 'UIMS'
        CDTLogger.log('toLife', { finalSCode: toLifeScode, ...logObj })
        return toLifeScode
      }

      if (toHomeAndAuto) {
        const toHomeAndAutoScode = keepCampaignKey ? currentScode : 'xspaidml'
        CDTLogger.log('toHomeAndAuto', {
          finalSCode: toHomeAndAutoScode,
          ...logObj,
        })
        return toHomeAndAutoScode
      }

      if (toParentDomain) {
        const toParentDomainScode = keepCampaignKey ? currentScode : 'UOMS'
        CDTLogger.log('toParentDomain', {
          finalSCode: toParentDomainScode,
          ...logObj,
        })
        return toParentDomainScode
      }

      if (!sCodeObj.domain) {
        CDTLogger.log('No domain found', logObj)
        return currentScode
      }

      if (currentDomain === domain) {
        CDTLogger.log('Same domain', logObj)
        return currentScode
      }

      // Handle other domain transitions
      switch (sCodeObj.type) {
        case 'SEO':
          const seoScode = domainData?.seo?.nextSCode
          CDTLogger.log('SEO SCode', { finalSCode: seoScode, ...logObj })
          return seoScode
        case 'REFERRER':
          const referrerScode = domainData?.referrer?.nextSCode
          CDTLogger.log('Referrer SCode', {
            finalSCode: referrerScode,
            ...logObj,
          })
          return referrerScode
        case 'DIRECT':
          const directScode = domainData?.direct?.nextSCode
          CDTLogger.log('Direct SCode', { finalSCode: directScode }, logObj)
          return directScode
        default:
          CDTLogger.warn('Default Case: No SCode found', {
            finalSCode: currentScode,
            ...logObj,
          })
          return currentScode
      }
    } catch (error) {
      CDTErrorHandler(error, 'getScodeByHistory')
      return currentScode
    }
  }

  /**
   * Sets the sCode in session storage after removing any quotes from the input string.
   * Also stores in localStorage for persistence across browser sessions.
   * @param {string} newSCode - The new sCode to be set in session storage.
   */
  const setScode = (newSCode) => {
    try {
      if (typeof newSCode !== 'string') {
        CDTLogger.error('setScode Error - Invalid sCode:', newSCode)
        return
      }

      // Safe guard to ensure sCode doesn't contain quotes or query params
      newSCode = newSCode.replace(/['"]/g, '')?.split('?')[0]

      setStorage('domain-tracking-scode', newSCode)
      setStorage('sCode', newSCode)
    } catch (error) {
      CDTErrorHandler(error, 'setScode')
    }
  }

  /* ______________________________________ Utility Functions ______________________________________ */

  /**
   * Checks if the current page was referred by a search engine.
   * @returns {boolean} True if the referrer is a search engine, false otherwise.
   */
  const isSearchEngineReferer = () => {
    try {
      const searchEngines = [
        'google',
        'bing',
        'yahoo',
        'duckduckgo',
        'ask',
        'baidu',
        'yandex',
      ]
      const referrer = getStorage('domain-tracking-referrer')
        ? getStorage('domain-tracking-referrer').toLowerCase()
        : document.referrer.toLowerCase()
      return searchEngines.some((engine) => referrer.includes(engine))
    } catch (error) {
      CDTErrorHandler(error, 'isSearchEngineReferer')
      return false
    }
  }

  /**
   * Finds and returns data from the MAPPED_DOMAINS array based on the provided domain.
   * @param {string} domain - The domain to search for in the MAPPED_DOMAINS array.
   * @returns {Object|undefined} The data object corresponding to the provided domain, or undefined if not found.
   */
  const getDataByDomain = (domain) => {
    try {
      const domainHost = getSanitizedHost(domain)
      return MAPPED_DOMAINS.find((x) => x.domains.includes(domainHost))
    } catch (error) {
      CDTErrorHandler(error, 'getDataByDomain')
      return undefined
    }
  }

  /**
   * Generates a device ID using browser fingerprinting.
   * @returns {string} A unique device ID generated using browser fingerprinting.
   */
  const generateDeviceID = () => {
    try {
      const txt = 'browser fingerprint'
      const canvas = document.createElement('canvas')
      const ctx = canvas.getContext('2d')
      // Check if the canvas is supported
      if (!ctx) return '' // or handle the error appropriately
      ctx.textBaseline = 'top'
      ctx.font = "14px 'Arial'"
      ctx.textBaseline = 'alphabetic'
      ctx.fillStyle = '#f60'
      ctx.fillRect(125, 1, 62, 20)
      ctx.fillStyle = '#069'
      ctx.fillText(txt, 2, 15)
      ctx.fillStyle = 'rgba(102, 204, 0, 0.7)'
      ctx.fillText(txt, 4, 17)

      const b64 = canvas.toDataURL().replace('data:image/png;base64,', '')
      const bin = atob(b64)
      const crc = [...bin].reduce(
        (prev, curr) => (prev << 5) - prev + curr.charCodeAt(0),
        0
      )

      // Convert to a base36 string to ensure it's alphanumeric

      const base36String = Math.abs(crc).toString(36)
      // Pad or slice the string to ensure a specific length (20 characters in this example)
      return base36String.padEnd(20, '0').slice(0, 20).toUpperCase()
    } catch (error) {
      CDTErrorHandler(error, 'generateDeviceID')
      return ''
    }
  }

  /**
   * Sets up DOM elements for the given domain.
   * @param {string} currentDomain - The current domain to set up elements for.
   * @returns {void}
   */
  const setDOMElements = (currentDomain) => {
    try {
      const domainHost = getSanitizedHost(currentDomain)

      if (!SUPPORTED_DOMAINS.includes(domainHost)) return

      if (!getStorage('domain-tracking-canvas')) {
        const canvasID = generateDeviceID()
        setStorage('domain-tracking-canvas', canvasID)
      }

      handleAllRedirects(domainHost)
    } catch (error) {
      CDTErrorHandler(error, 'setDOMElements')
    }
  }

  /**
   * Overrides the window.history.pushState method to add custom logging and checks.
   */
  const safeHistoryPushStateOverride = () => {
    const originalPushState = window.history.pushState

    window.history.pushState = function (...args) {
      const isAddSearchScript = new Error().stack.includes(
        'addsearch-search-ui.min.js'
      )

      // Force pushState to do nothing if coming from addsearch-search-ui.min.js & search state is empty
      // * INFO: Fixes back button functionality.
      if (isAddSearchScript) {
        return
      }
      return originalPushState.apply(this, args)
    }
  }

  /**
   * Executes a callback function when the document is ready.
   * @param {Function} callback - The function to be executed when the document is ready.
   */
  const ready = (callback) => {
    try {
      if (document.readyState !== 'loading') {
        callback()
      } else if (document.addEventListener) {
        document.addEventListener('DOMContentLoaded', callback)
      } else if ('attachEvent' in document) {
        document.attachEvent('onreadystatechange', () => {
          if (document.readyState === 'complete') callback()
        })
      }
    } catch (error) {
      CDTErrorHandler(error, 'ready')
    }
  }

  /* ______________________________________ Main Execution ______________________________________ */

  /**
   * Prepares the environment for cross-domain tracking by setting up necessary variables and functions.
   * Logs the Cross Domain Tracking Version and performs various checks and setups including setting the first URL,
   * determining the code origin, setting the sCode, and setting DOM elements.
   */
  const prepareEnvironment = () => {
    try {
      console.log(
        `Cross Domain Tracking Version: ${CROSS_DOMAIN_TRACKING_VERSION}`
      )
      // ! Override the window.history.pushState method call from AddSearch Search UI script
      //   - Prevents the script from breaking the back button functionality
      safeHistoryPushStateOverride()

      let currentDomain = getSanitizedHost(window.location.href)
      const currentUrl = window.location.href
      const parentDomain = getSanitizedHost(getEnvironmentDomain('SQ'))
      const parentDomains = Object.values(ENVIRONMENT_URLS['SQ'])
      const isParentDomain = parentDomains.includes(currentDomain)
      const lsqDomain = getEnvironmentDomain('LSQ')
      const haaDomain = getEnvironmentDomain('HAA')
      const msqDomain = getEnvironmentDomain('MSQ')
      const isHaaPath = urlPathStartsWith(
        '/auto-and-home-insurance',
        currentUrl
      )
      const isLsqPath = urlPathStartsWith('/life-insurance', currentUrl)
      const isMsqPath = urlPathStartsWith('/medicare', currentUrl)
      const isFirstPageVisit =
        document.referrer === '' || document.referrer.includes(currentDomain)

      if (isParentDomain) {
        if (isMsqPath) currentDomain = msqDomain
        if (isLsqPath) currentDomain = lsqDomain
        if (isHaaPath) currentDomain = haaDomain
      }

      // First opportunity: if current page qualifies and no conflicting attribution, attempt override
      attemptPageSpecificSeoOverride(currentDomain)

      if (!getStorage('firstURL')) {
        const firstURL = getURLVariable('first_url') || window.location.href
        setStorage('firstURL', firstURL)
        setStorage('domain-tracking-first-url', firstURL)
      }

      // Hydrate campaign phone early from pass_phone if present and not already stored
      try {
        const incomingPassPhone = getURLVariable('pass_phone')
        if (incomingPassPhone) {
          // Scope hydration only for MSQ/MHL domains or parent domain Medicare path
          const msqDomains = Object.values(ENVIRONMENT_URLS['MSQ']).map(getSanitizedHost)
          const mhlDomains = Object.values(ENVIRONMENT_URLS['MHL']).map(getSanitizedHost)
          const currentHost = getSanitizedHost(window.location.href)
          // Broaden Medicare path detection for parent-domain scoping:
          const pathIsMedicare = /^\/medicare(\/|-|$)/i.test(window.location.pathname)
          if (msqDomains.includes(currentHost) || mhlDomains.includes(currentHost) || pathIsMedicare) {
            const decodedPhone = decodeURIComponent(incomingPassPhone)
            const sessionRaw = getStorage('site_session_data')
            const sessionObj = sessionRaw ? JSON.parse(sessionRaw) : {}
            if (!sessionObj.site_campaign_phone) {
              sessionObj.site_campaign_phone = decodedPhone
              setStorage('site_session_data', JSON.stringify(sessionObj), 'session')
            }
          }
        }
      } catch (e) {
        CDTLogger.warn('pass_phone hydration failed', e)
      }

      if (!getStorage('pass_lp')) {
        const incomingPassLp = getURLVariable('pass_lp')
        if (incomingPassLp) {
          setStorage('pass_lp', incomingPassLp)
        }
      }

      if (
        !getStorage('domain-tracking-url-variables') &&
        window.location.search
      ) {
        setStorage('domain-tracking-url-variables', window.location.search)
      }

      // !INFO: Always keep the referrer up to date
      setStorage('domain-tracking-referrer', document.referrer)

      const siteSessionData = getStorage('site_session_data')
      if (getURLVariable('pass_sid') && siteSessionData) {
        const siteSession = JSON.parse(siteSessionData)
        siteSession.site_session_id = getURLVariable('pass_sid')
        setStorage('site_session_data', JSON.stringify(siteSession))
      }

      const currentScode =
        getURLVariable('sCode') ||
        getURLVariable('keyword') ||
        getStorage('sCode') ||
        getStorage('domain-tracking-scode')

      CDTLogger.log('Cross Domain Tracking Info:', {
        currentUrl: getSanitizedURL(window.location.href),
        currentScode,
        currentDomain: getSanitizedHost(window.location.href),
        modifiedCurrentDomain: currentDomain,
        referral: {
          referrer: document.referrer,
          prevReferrer: document.referrer.includes(
            getSanitizedHost(window.location.href)
          ),
        },
        checks: {
          isFirstPageVisit,
          isParentDomain,
          isHaaPath,
          isLsqPath,
          isMsqPath,
        },
        domains: {
          envDomains: {
            currentDomain,
            haaDomain,
            lsqDomain,
            msqDomain,
            parentDomain,
          },
          MAPPED_DOMAINS,
          SUPPORTED_DOMAINS,
        },
      })
      if (currentScode) {
        setScode(currentScode)
        // Re-apply override in case stored/currentScode was base SEO and needs upgrading to page-specific
        attemptPageSpecificSeoOverride(currentDomain)
        ready(() => setDOMElements(currentDomain))
        return
      }

      // Check if we already have an sCode in session storage or local storage before determining source
      const existingScode =
        getStorage('sCode') || getStorage('domain-tracking-scode')
      const isSearchReferer = isSearchEngineReferer()

      if (existingScode) {
        // If we already have an sCode in storage, keep using it
        CDTLogger.log('Using existing sCode', {
          existingScode,
          local:
            getStorage('sCode', 'local') ||
            getStorage('domain-tracking-scode', 'local'),
          session:
            getStorage('sCode', 'session') ||
            getStorage('domain-tracking-scode', 'session'),
        })
        setScode(existingScode)
        attemptPageSpecificSeoOverride(currentDomain)
      } else if (isFirstPageVisit || isSearchReferer) {
        const codeOrigin = isSearchReferer ? 'SEO' : 'DIRECT'
        const sCode = getScodeByOrigin(currentDomain, codeOrigin)
        CDTLogger.log('sCode', { sCode, codeOrigin, currentDomain })
        setScode(sCode)
        attemptPageSpecificSeoOverride(currentDomain)
      } else {
        setScode(getScodeByOrigin(currentDomain, 'REFERRER'))
      }

      ready(() => setDOMElements(currentDomain))
    } catch (error) {
      CDTErrorHandler(error, 'prepareEnvironment')
    }
  }

  /* ______________________________________ Script Execution ______________________________________ */

  // Enable debug mode if needed (e.g., based on a URL parameter or environment variable)
  if (
    getURLVariable('cdt_debug') === 'true' ||
    getStorage('cdt_debug') === 'true'
  ) {
    CDT_DEBUG.setDebug(true)
  }

  getTtlExpiryOverride() // Set the initial expiry

  prepareEnvironment()

  function filterUnsafeArgs(args) {
    return Array.isArray(args)
      ? args.map((arg) =>
          isSafeForLogging(arg) ? arg : '[Filtered: unsafe object]'
        )
      : isSafeForLogging(args)
      ? args
      : '[Filtered: unsafe object]'
  }

  function isSafeForLogging(obj) {
    // Exclude window, document, DOM nodes, or objects with cross-origin issues
    if (!obj) return true
    if (typeof obj === 'object') {
      if (obj === window || obj === document) return false
      if (typeof Node !== 'undefined' && obj instanceof Node) return false
      if (typeof Window !== 'undefined' && obj instanceof Window) return false
    }
    return true
  }
})()
